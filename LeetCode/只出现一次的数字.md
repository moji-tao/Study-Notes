@[TOC](目录)
# 只出现一次的数字Ⅰ
## 题目
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

	输入: [2,2,1]
	输出: 1
	
	输入: [4,1,2,1,2]
	输出: 4
## 思路
利用异或运算

	N^N=0 
	N^0=N
	N^N^M=N
	N^M^N=N
由此可以看出，我们可以对数组中的数遍历一遍进行异或运算
这样，出现了偶数次的数字就会被消除，留下出现奇数次的数字
## 代码实现

```cpp
    int singleNumber(vector<int>& nums) 
    {
        int k = 0;
        for(int i = 0; i<nums.size(); ++i)
        {
            k ^= nums[i];
        }
        return k;
    }
```

# 只出现一次的数字Ⅱ
## 题目
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

	输入：nums = [2,2,3,2]
	输出：3
	
	输入：nums = [0,1,0,1,0,1,99]
	输出：99
## 解题思路
我们用示例一进行解释
|十进制|二进制  |
|--|--|
|  2| 0010 |
|  2| 0010 |
|  3| 0011 |
|  2| 0010 |

将对应的二进制相加，得

|0|0|4|1|
|--|--|--|--|

这样我们把其中的每个数mod 3

|0|0|1|1|
|--|--|--|--|

这样就可以得出 **3**

## 代码实现

```cpp
    int singleNumber(vector<int>& nums) 
    {
        vector<int> bits(32, 0);
        
        for(int i = 0; i < nums.size(); ++i)
            for(int j = 0; j < 32; ++j)
                if(nums[i] & (1 << j))
                    ++bits[j];

        int rtn = 0;

        for(int i = 0; i < bits.size(); ++i)
            if(bits[i] % 3 == 1)
                rtn += (1 << i);

        return rtn;
    }
```

# 只出现一次的数字Ⅲ
## 题目
给定一个整数数组 *nums*，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

	输入：nums = [1,2,1,3,2,5]
	输出：[3,5]
	解释：[5, 3] 也是有效的答案。
	
	输入：nums = [-1,0]
	输出：[-1,0]
	
	输入：nums = [0,1]
	输出：[1,0]
	
## 解题思路
我们仍然可以对数组的每个数字进行异或运算，出现偶数词的数字被清除
这样我们就得到了出现一次的两个数字的异或数（我们称为**ans**）
由异或运算的性质我们可以知道，同位得0，异位得1
假设我们得到的**ans**的二进制数为101101
可以看出，最低位是1，就可以得出那两个出现一次的数最低位分别是0和1
由此可以将原数组分为两组，最低位是0的一组，最低位是1的一组
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5e36594eb8aaac49fd103d8182fb0b7b.png#pic_center)
然后对用得到的**ans**分别对这个分组进行异或，分别得到了两个只出现了一次的数字（分组里出现偶数次的数字被消掉，出现了一次的数字与**ans**进行异或后消掉一个）

## 代码实现

```cpp
    vector<int> singleNumber(vector<int>& nums) 
    {
        int ans = 0;
        for(int i = 0; i<nums.size(); ++i)
            ans ^= nums[i];

        int tmp = 1;
        while((ans & tmp) == 0)
            tmp <<= 1;
        
        int ans2 = 0;
        for(int i = 0; i<nums.size(); ++i)
            if((tmp & nums[i]) != 0)
                ans2 ^= nums[i];

        vector<int> rtn;
        rtn.push_back(ans2);
        rtn.push_back(ans2 ^ ans);
        return rtn;
    }
```
